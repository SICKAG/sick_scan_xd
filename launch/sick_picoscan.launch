<?xml version="1.0"?>
<launch>

    <!-- Launch sick_picoscan -->
    <!-- env name="ROSCONSOLE_CONFIG_FILE" value="/tmp/rosconsole_loglevel_warn.conf" / -->
    <arg name="hostname" default="192.168.0.1"/>  <!-- IP address of picoScan150, overwrites default ip address "192.168.0.1" in sick_scansegment_xd.yaml -->
    <arg name="udp_receiver_ip" default=""/>        <!-- UDP destination IP address (ip address of udp receiver), overwrites default in sick_scansegment_xd.yaml -->
    <arg name="nodename" default="sick_picoscan"/>
    <arg name="publish_topic" default="/cloud" />                         <!-- ros topic to publish received msgpack data converted top PointCloud2 messages, default: "/cloud" -->
    <arg name="publish_topic_all_segments" default="/cloud_fullframe" />  <!-- ros topic to publish PointCloud2 messages of all segments (360 deg), default: "/cloud_fullframe" -->
    <arg name="publish_frame_id" default="world" />                       <!-- frame id of ros PointCloud2 messages, default: "world" -->
    <arg name="add_transform_xyz_rpy" default="0,0,0,0,0,0"/>
    <arg name="scandataformat" default="2"/>                              <!-- ScanDataFormat: 1 for msgpack or 2 for compact scandata, default: 2 -->
    <node name="$(arg nodename)" pkg="sick_scan" type="sick_generic_caller" respawn="false" output="screen" required="true">    
        <param name="scanner_type" type="string" value="sick_picoscan"/>

        <!-- network settings: -->
        <param name="hostname" type="string" value="$(arg hostname)" />                     <!-- IP address of picoScan150 to post start and stop commands, f.e. "192.168.0.1" (default) -->
        <param name="port" type="int" value="2115" />                                       <!-- IP port of picoScan150 to post start and stop commands -->
        <param name="udp_receiver_ip" type="string" value="$(arg udp_receiver_ip)" />       <!-- UDP destination IP address (ip address of udp receiver), f.e. "192.168.0.140" -->

        <!-- sick_scansegment_xd basic settings: -->
        <param name="udp_sender" type="string" value="" />                                  <!-- Use "" (default) to receive msgpacks from any udp sender, use "127.0.0.1" to restrict to localhost (loopback device), or use the ip-address of a picoscan lidar or picoscan emulator -->
        <param name="udp_port" type="int" value="2115" />                                   <!-- default udp port for picoScan150 resp. picoScan150 emulator is 2115 -->
        <param name="publish_topic" type="string" value="$(arg publish_topic)" />           <!-- ros topic to publish received msgpack data converted top PointCloud2 messages, default: "/cloud" -->
        <param name="publish_topic_all_segments" type="string" value="$(arg publish_topic_all_segments)" />  <!-- ros topic to publish PointCloud2 messages of all segments (360 deg), default: "/cloud_fullframe" -->
        <param name="all_segments_min_deg" type="double" value="-138.0" />                  <!-- angle range covering all segments: all segments pointcloud on topic publish_topic_all_segments is published,  -->
        <param name="all_segments_max_deg" type="double" value="+138.0" />                  <!-- if received segments cover angle range from all_segments_min_deg to all_segments_max_deg. -180...+180 for multiScan136 (360 deg fullscan), -138...+138 for picoScan (fullscan) -->
        <param name="publish_frame_id" type="string" value="$(arg publish_frame_id)" />     <!-- frame id of ros PointCloud2 messages, default: "world" -->
        <param name="udp_input_fifolength" type="int" value="20" />                         <!-- max. udp input fifo length(-1: unlimited, default: 20 for buffering 1 second at 20 Hz), elements will be removed from front if number of elements exceeds the fifo_length -->
        <param name="msgpack_output_fifolength" type="int" value="20" />                    <!-- max. msgpack output fifo length(-1: unlimited, default: 20 for buffering 1 second at 20 Hz), elements will be removed from front if number of elements exceeds the fifo_length -->
        <param name="verbose_level" type="int" value="1" />                                 <!-- verbose_level <= 0: quiet mode, verbose_level == 1: print statistics, verbose_level == 2: print details incl. msgpack data, default: 1 -->
        <param name="measure_timing" type="bool" value="True" />                            <!-- measure_timing == true: duration and latency of msgpack conversion and export is measured, default: true -->
        <param name="export_csv" type="bool" value="False" />                               <!-- export msgpack data to csv file, default: false -->
        <param name="export_udp_msg" type="bool" value="False" />                           <!-- true : export binary udpand msgpack data to file(*.udp and* .msg), default: false -->
        <param name="logfolder" type="string" value="" />                                   <!-- output folder for logfiles, default: "" (no logging) -->
        <param name="send_udp_start" type="bool" value="False" />                           <!-- Send udp start string to picoScan150 -->
        <param name="send_udp_start_string" type="string" value="magicalActivate" />        <!-- udp string to start picoScan150 -->
        <param name="udp_timeout_ms" type="int" value="60000" />                            <!-- Timeout for udp messages in milliseconds, default: 60*1000 -->
        <param name="scandataformat" type="int" value="$(arg scandataformat)" />            <!-- ScanDataFormat: 1 for msgpack or 2 for compact scandata, default: 1 -->
        
        <!-- Optional range filter configuration: If the range of a scan point is less than range_min or greater than range_max, the point can be filtered. -->
        <!-- Depending on parameter range_filter_handling, the following filter can be applied for points with a range not within [range_min, range_max],   -->
        <!-- see enumeration RangeFilterResultHandling in range_filter.h:                                           -->
        <!--   0: RANGE_FILTER_DEACTIVATED,  do not apply range filter (default)                                    -->
        <!--   1: RANGE_FILTER_DROP,         drop point, if range is not within [range_min, range_max]              -->
        <!--   2: RANGE_FILTER_TO_ZERO,      set range to 0, if range is not within [range_min, range_max]          -->
        <!--   3: RANGE_FILTER_TO_RANGE_MAX, set range to range_max, if range is not within [range_min, range_max]  -->
        <!--   4: RANGE_FILTER_TO_FLT_MAX,   set range to FLT_MAX, if range is not within [range_min, range_max]    -->
        <!--   5: RANGE_FILTER_TO_NAN        set range to NAN, if range is not within [range_min, range_max]        -->
        <!-- Note: Range filter applies only to Pointcloud messages, not to LaserScan messages.                     -->
        <!-- Using range_filter_handling 4 or 5 requires handling of FLT_MAX and NAN values in an application.      -->
        <param name="range_min" type="double" value="0.0"/>
        <param name="range_max" type="double" value="120.0"/>
        <param name="range_filter_handling" type="int" value="0"/>
        
        <!-- Apply an additional transform to the cartesian pointcloud, default: "0,0,0,0,0,0" (i.e. no transform) -->
        <!-- Note: add_transform_xyz_rpy is specified by 6D pose x, y, z, roll, pitch, yaw in [m] resp. [rad] -->
        <!-- It transforms a 3D point in cloud coordinates to 3D point in user defined world coordinates: --> 
        <!-- add_transform_xyz_rpy := T[world,cloud] with parent "world" and child "cloud", i.e. P_world = T[world,cloud] * P_cloud -->
        <!-- The additional transform applies to cartesian lidar pointclouds and visualization marker (fields) -->
        <!-- It is NOT applied to polar pointclouds, radarscans, ldmrs objects or other messages -->
        <param name="add_transform_xyz_rpy" type="string" value="$(arg add_transform_xyz_rpy)" /> 

        <!-- SOPAS settings: -->
        <param name="sopas_tcp_port" type="string" value="2111" />                          <!-- TCP port for SOPAS commands, default port: 2111 -->
        <param name="start_sopas_service" type="bool" value="True" />                       <!-- True: sopas services for CoLa-commands are started (ROS only), default: true -->
        <param name="send_sopas_start_stop_cmd" type="bool" value="True" />                 <!-- True: picoScan150 start and stop command sequence ("sWN ScanDataEnable 0/1" etc.) are sent after driver start and stop, default: true -->
        <param name="sopas_cola_binary" type="bool" value="False" />                        <!-- False: SOPAS uses CoLa-A (ascii, default, recommended), CoLa-B (true, binary) currently experimental -->
        <param name="sopas_timeout_ms" type="int" value="5000" />                           <!-- Timeout for SOPAS response in milliseconds, default: 5000 -->
        <param name="client_authorization_pw" type="string" value="F4724744" />             <!-- Default password for client authorization -->
        
        <!-- picoScan150 filter settings -->
        <param name="host_read_filtersettings" type="bool" value="True" />                                    <!-- Read picoScan150 settings for FREchoFilter, LFPangleRangeFilter and LFPlayerFilter at startup, default: true -->
        <param name="host_FREchoFilter" type="int" value="0" />                                               <!-- Optionally set FREchoFilter with 0 for FIRST_ECHO (default, EchoCount=1), 1 for ALL_ECHOS (EchoCount=3), or 2 for LAST_ECHO (EchoCount=1) -->
        <param name="host_set_FREchoFilter" type="bool" value="False" />                                      <!-- If true, FREchoFilter is set at startup (default: false) -->
        
        <!-- Msgpack validation -->
        <param name="msgpack_validator_enabled" type="bool" value="False" />                                  <!-- true: check msgpack data for out of bounds and missing scan data, false: no msgpack validation (default) -->
        <param name="msgpack_validator_verbose" type="int" value="1" />                                       <!-- 0: print error messages, 1: print error and informational messages, 2: print error and all messages -->
        <param name="msgpack_validator_discard_msgpacks_out_of_bounds" type="bool" value="True" />            <!-- true: msgpacks are discarded if scan data out of bounds detected, false: error message if a msgpack is not validated -->
        <param name="msgpack_validator_check_missing_scandata_interval" type="int" value="9" />               <!-- check msgpack for missing scandata after collecting N msgpacks, default: N = 9 segments. Increase this value to tolerate udp packet drops. Use 9 to check each full scan. -->
        <param name="msgpack_validator_required_echos" type="string" value="0 1 2" />                         <!-- default: "0 1 2" for all echos (FREchoFilter=1) or "0" for one echo (FREchoFilter=0) -->
        <param name="msgpack_validator_azimuth_start" type="double" value="-138.0" />                         <!-- picoScan150: fullscan, -138 to +138 deg -->
        <param name="msgpack_validator_azimuth_end" type="double" value="+138.0" />                           <!-- picoScan150: fullscan, -138 to +138 deg -->
        <param name="msgpack_validator_elevation_start" type="double" value="0.0" />                          <!-- picoScan150: 1 layer -->
        <param name="msgpack_validator_elevation_end" type="double" value="0.0" />                            <!-- picoScan150: 1 layer -->
        <param name="msgpack_validator_valid_segments" type="string" value="0 1 2 3 4 5 6 7 8" />             <!-- indices of valid segmentes, default for full scan: 9 segments -->
        <param name="msgpack_validator_layer_filter" type="string" value="1" />                               <!-- picoScan150: 1 layer -->

    </node>

</launch>

